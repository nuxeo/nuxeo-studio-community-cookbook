<!--  nuxeo-carousel-display

  INFO: This element uses nuxeo-se-document-viewer and expects it to be in the elements folder.
        => it is available in the NUxeo Studio Community Cookbook: make sure to also have it
          deployed, and if deployed elsewhere than in "elements", change the import path below.

  Displays a carousel of documents, loaded from a PageProvider. With previous+next and Go To buttons.
  The element can be used (see below about the with/without metadata or blobactions):
    1)  Standalone, with its own nuxeo-page-provider (see nuxeo-carousel-document-content.html):
            <nuxeo-carousel-display
                id="carouselDisplay"
                page-provider="myPageProvider"
                params="[[params]]"
                with-metadata
                without-blob-actions>
            </nuxeo-carousel-display>

        The element exposes the parentDocumentChanged(document) API, to be called _by the parent_
        when the parent document changes. The parenet element may also have changed the params, based
        on the new main document (see nuxeo-carousel-document-content for an example)

    2)  Inside a nuxeo-results. Following nuxeo-results pattern, you just add
        nuxeo-carousel-display with the required fields (class="results", a name and an icon),
            <nuxeo-results . . .>

              . . . data-grid, data-table, ...

              <nuxeo-carousel-display
                name="carousel"
                icon="icons:view-carousel"
                class="results"
                page-provider="[[nxProvider]]"
                without-metadata
                without-blob-actions>
              </nuxeo-carousel-display>
        You don't set params, this is done by the caller.
      
        ==============================
        IMPORTANT
        ==============================
        The expression [[nxProvider]] is the *required* value to use in the context of
        a nuxeo-results, do not change it.
  
  In all cases, you can also pass the schemas property. It is set by default to "*", so all schemas
  are fetched. You can restrict that to only the schemas you need to display, for example:
      <nuxeo-carousel-display
        page-provider="myPageprovider"
        schemas="dublincore,common,uid,file,product,company">
      </nuxeo-carousel-display>

  Also, the element fetches documents when it is time to render them (hence why you don't need to pass
  enrichers, the element chooses them internally).


    ========================================
    IMPORTANT
    ========================================
    If you set schemas, make sure to fetch the schemas you want to display in the metadata layout
    of your document(s).

    In both cases, the parameters are loaded once. When the user clicks the next (or previous)
    arrow and it requests to fetch next (or previous) page, it calls the provider with the same
    parameters (and the prev/next page).

    =====================
    Attributes/Properties
    =====================
    - nxProvider: The page provider to use
    - params: The parameters to pass to the page provider
    - schemas: The schemas to fetch for each document. Default is "*"

    Boolean attributes are always a challenge in polymer, since you can't explicitely pass a Boolean
    attribute to false (<my-element my-bool> and <my-element my-bool="false"> both mean true). So we
    provide both withX and withoutX:
    - withMetadata: If true, display the metadata panel. Default is true.
    - withoutMetadata: If true, do not display the metadata panel. Default is false.
    - withBlobActions: If true, display blob actions in the document viewer. Default is false.
    - withoutBlobActions: If true, do not display blob actions in the document viewer.

    Default values display the metadata and not the blob actions

    =====================
    Other Info
    =====================
    - Navigation with arrow keys is done by giving the focus to the whole carousel container (then
      handling keydown events).
    - Translation keys are handled with default EN values. Keys are:
      - carousel.button.goTo: "Go to…" (Button label)
      - carousel.prompt.goTo:
          - Default is "Go to position (1..<VALUE>):"
          - If your label has "<VALUE>", it will be replaced by the total number of entries.
      - carousel.converting: "Converting to PDF..." (Loading message)
  -->
<link rel="import" href="../elements/nuxeo-se-document-viewer.html">
<dom-module id="nuxeo-carousel-display">
  <template>
    <style include="nuxeo-styles">
      :host {
        display: flex;
        flex-direction: column;
        box-sizing: border-box;
        --toolbar-height: 56px;
        outline: none; /* Remove default browser focus outline */

        /* viewport is always way bigger than the window. Looks like it's because of the toolbar
           and other elements above (like the tabs).
           So we have toolbar (56px)
                      + document tabs height (46px)
                      + page content margin (16px)
                       => 62 */
        height: calc(100vh - var(--toolbar-height) - 62px);
      }

      /* Layout part must not tkae the whole width */
      :host([opened]) .metadataContainer {
        flex: 0 0 30%;
        max-width: 30%;
      }

      .toolbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        height: var(--toolbar-height);
        padding: 0 12px;
        box-sizing: border-box;
        border-bottom: 1px solid var(--nuxeo-border, #e8e8e8);
        background: var(--nuxeo-box);
        margin-bottom: 5px;
        flex: 0 0 auto;
      }

      .title {
        font-size: 1.1rem;
        font-weight: 600;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        padding-right: 12px;
      }

      .nav {
        display: inline-flex;
        gap: 4px;
        align-items: center;
      }

      paper-icon-button.chevron {
        --paper-icon-button: {
          width: 48px;
          height: 48px;
        };
      }

      .body {
        display: flex;
        flex: 1 1 auto; /* All space below toolbar */
        min-height: 0;  /* Required for scrolling */
        box-sizing: border-box;
      }

      .viewerContainer,
      .metadataContainer {
        display: flex;
        flex-direction: column;
        height: 100%;
        min-height: 0;  /* Allows for scrolling  */
        overflow: hidden;
      }

      .viewerContainer {
        flex: 1 1 auto;
        min-width: 0;
      }
      
      #metadataCard {
        flex: 1 1 auto;
        min-height: 0;
        overflow: auto;
        border-right: 1px solid var(--nuxeo-border, #e0e0e0);
      }

      .empty {
        padding: 24px;
        color: var(--nuxeo-text-default, #8f8f8f);
      }

      .nuxeoPageBackground {
        background-color: var(--nuxeo-page-background, #f5f5f5);
      }
    </style>

    <!-- So we have the base URL, including /nuxeo or whatever was configured, if changed -->
    <nuxeo-connection id="nxcon"></nuxeo-connection>

    <nuxeo-document
      id="currentDocument"
      enrichers="preview,breadcrumb,renditions,thumbnail,permissions"
      schemas="[[schemas]]"
      headers='{"fetch-document": "properties", "translate-directoryEntry": "label", "fetch-directoryEntry": "parent"}'>
    </nuxeo-document>

    <!-- Toolbar -->
    <div class="toolbar">
      <div class="title" >
        <a href$="[[_url(_currentdocument.uid)]]" target="_blank">[[_currentdocument.title]]</a>
      </div>
      <div class="nav">
        <paper-icon-button icon="chevron-left"
                            class="chevron"
                            on-tap="_prev"
                            disabled$="[[_isPrevDisabled(_entrieslength, _index, _loading)]]"
          aria-label="Previous"></paper-icon-button>

        <!-- Position indicator: “currentIndex / total” -->
        <span aria-live="polite">[[_positionLabel(nxProvider, _index, _entrieslength)]]</span>

        <paper-icon-button icon="chevron-right"
                            class="chevron"
                            on-tap="_next"
                            disabled$="[[_isNextDisabled(_entrieslength, _index, _loading)]]"
          aria-label="Next"></paper-icon-button>

        <!-- Jump to Nth (uses simple prompt) -->
        <paper-button id="goTo"
                      class="secondary"
                      style="vertical-align: middle;"
                      on-tap="_promptJump"
                      raised>[[_my_i18n('carousel.button.goTo', 'Go to…')]]</paper-button>
      </div>
    </div>
    
    <!-- Carousel -->
    <template is="dom-if" if="[[_hasDocuments(_documents)]]" restamp>
      <div class="body">
        <!-- Viewer -->
        <div class="viewerContainer">
          <template is="dom-if" if="[[withBlobActions]]" restamp>
            <!-- By default, blob actions are displayedb-->
            <nuxeo-se-document-viewer document="[[_currentdocument]]"></nuxeo-se-document-viewer>
          </template>
          <template is="dom-if" if="[[withoutBlobActions]]" restamp>
            <nuxeo-se-document-viewer document="[[_currentdocument]]"
                                      without-blob-actions></nuxeo-se-document-viewer>
          </template>
        </div>
        
        <!-- Metadata -->
        <template is="dom-if" if="[[withMetadata]]" restamp>
          <div class="metadataContainer">
            <nuxeo-card id="metadataCard" 
                        icon="nuxeo:details"
                        heading="[[i18n('documentPage.details.opened')]]"
                        collapsible
                        class="nuxeoPageBackground"
                        on-tap="_collapseExpandMetadata">
              <nuxeo-document-info document="[[_currentdocument]]"></nuxeo-document-info>
              <div class="empty"></div>
              <nuxeo-document-metadata document="[[_currentdocument]]"></nuxeo-document-metadata>
            </nuxeo-card>
          </div>
        </template>
      </div>
    </template>

    <template is="dom-if" if="[[!_hasDocuments(_documents)]]" restamp>
      <div class="empty">[[i18n('searchResults.noResults')]]</div>
    </template>
  </template>

  <script>
    (function () {
      'use strict';

      Polymer({
        is: 'nuxeo-carousel-display',
        // IronResizableBehavior required to compute visibility and avoid fetching values
        // every time the user refreshes a page, even when no carousel is visible.
        behaviors: [Nuxeo.LayoutBehavior, Polymer.IronResizableBehavior],

        properties: {
          // ========================================
          // Properties set by parent
          // ========================================
          // The name *must be* nxProvider in order to be recognized by nuxeo-results.
          nxProvider: {
            type: Object,
            observer: "_pageProviderChanged"
          },

          schemas: {
            type: String,
            value: "*"
          },

          params: Object,

          // Always a challenge to use real booleans for attributes.
          withMetadata: {
            type: Boolean,
            value: true,
          },
          withoutMetadata: {
            type: Boolean,
            value: false
          },

          withBlobActions: {
            type: Boolean,
            value: false
          },
          withoutBlobActions: {
            type: Boolean,
            value: true
          },

          // ========================================
          // "Private" properties
          // ========================================
          // This is a "documents" entity-type 
          _documents: {
            type: Object,
            observer: '_documentsChanged'
          },

          // Current index within the curren entries.
          _index: {
            type: Number,
            value: 0,
            notify: true,
            observer: '_indexChanged',
          },

          // Current document to display
          _currentdocument: {
            type: Object,
            notify: true
          },

          _loading: {
            type: Boolean,
            value: false
          },

          _visible: {
            type: Boolean,
            value: false,
            observer: '_visibleChanged'
          },

          _hasLoadedOnce: {
            type: Boolean,
            value: false
          },

          // Helper(s), to avoid calling functions or obj.property.property.property.etc.
          _entrieslength: {
            type: Number,
            value: 0
          },

          _pageProviderInfo: {
            type: Object,
            value: {}
          }
        },

        // ==================================================
        // Listeners
        // ==================================================
        // Detect when the carousel becomes visible
        listeners: {
          'iron-resize': '_computeVisible',
        },

        _computeVisible() {
          this._visible = Boolean(this.offsetWidth || this.offsetHeight);
        },

        _visibleChanged: function(newValue) {
          if (newValue) {
            this._firstFetch();
          }
        },

        // ==================================================
        // **Required callbacks** when inside a nuxeo-results
        // ==================================================
        // These are called only in the context of a nuxeo-results.
        clearSelection: function() {
          // No selection management in carousel
        },

        reset: function() {
          this._documents = null;
          this._entrieslength = 0;
          this._index = 0;
          this._currentdocument = null;
        },

        selectItems: function() {
          // No selection management in carousel
        },

        // The parent nuxeo-results calls fetch() to load data
        // and expects the promise to be returned.
        fetch: function() {
          const pp = this.nxProvider;
          if (!pp || !pp.fetch) {
            return Promise.resolve(); // Make sure to return something.
          }

          const result = pp.fetch();
          if (result) {
            return result.then((result) => {
                this._documents = result;
                this._entrieslength = result.entries.length;
                this._index = 0;
              })
          }
        },

        // ==================================================
        // DOM
        // ==================================================
        ready: function() {
          // Make the carousel focusable
          this.tabIndex = 0;

          // Handle visibility of stuff
          if(this.hasAttribute('without-metadata')) {
            this.withMetadata = !this.withoutMetadata;
          } else if(this.hasAttribute('with-metadata')) {
            this.withoutMetadata = !this.withMetadata;
          }

          if(this.hasAttribute('with-blob-actions')) {
            this.withoutBlobActions = !this.withBlobActions;
          } else if(this.hasAttribute('without-blob-actions')) {
            this.withBlobActions = !this.withoutBlobActions;
          }
        },

        attached: function () {
          this._onKeyDownBound = this._onKeyDown.bind(this);
          this.addEventListener('keydown', this._onKeyDownBound);
        },
        
        detached: function () {
          this.removeEventListener('keydown', this._onKeyDownBound);
        },

        // The nuxeo-card is collapsible. We don't handle the show-hide of elements, we
        // just change background color.
        _collapseExpandMetadata: function() {
          const card = this.$$('#metadataCard');
          if (card) {
            if(card.opened) {
              card.classList.remove('nuxeoPageBackground');
            } else {
              card.classList.add('nuxeoPageBackground');
            }
          }
        },

        // ==================================================
        // Observers
        // ==================================================
        // Called by parent, when the main folderish document changes.
        // The params and all have been reset to new values
        parentDocumentChanged: function() {
          this._hasLoadedOnce = false;
          this._firstFetch();
        },

        _pageProviderChanged: function(newValue) {
          if(newValue) {
            this._hasLoadedOnce = false;
            this._firstFetch();
          }
        },

        _documentsChanged: function (newValue) {
          if (!newValue) {
            return;
          }

          // Assume this is a "documents" entity type
          // But let's check it once, here
          if(!newValue["entity-type"] || newValue["entity-type"] !== "documents") {
            throw new Error("documents should be an object with its 'entity-type' property set to 'documents'.");
          }
          let len = newValue.entries.length;
          this._entrieslength = len;

          if(this.$$ && this.$$('#goTo')) {
            this.$$('#goTo').disabled = (len === 0);
          }
          if (len === 0) {
            this._index = 0;
            this._currentdocument = null;
            return;
          }
          this._refreshCurrent();
        },

        _indexChanged: function (newValue, prevValue) {
          this._refreshCurrent();
        },

        _hasDocuments: function (docs) {
          return docs && docs.entries && docs.entries.length > 0;
        },

        // We want the minimum from the provider, since each document is loaded via the nuxeo-document when displayed
        _prepareProvider: function() {
          const pp = this.nxProvider;
          if (!pp) {
            return;
          }

          // Deep copy required
          this._pageProviderInfo = {
            enrichers: pp.enrichers ? structuredClone(pp.enrichers) : {},
            schemas: pp.schemas,
            headers: pp.headers ? structuredClone(pp.headers) : {}
          };

          pp.enrichers = {};
          pp.schemas = "uid";// Trick, because if you pass empty string, it translates to "*"
          let headers = structuredClone(pp.headers);
          // Remove as much headers as possible.
          if(Object.keys(headers).length > 0) {
            ["properties",
             "enrichers.document",
             "fetch.document",
             "X-NXfetch-document",
             "fetch-aggregate",
             "translate-directoryentry",
             "X-NXtranslate-directoryEntry"].forEach((key) => {
              if(key in headers) {
                delete headers[key];
              }
            }); 
          }
          headers.skipAggregates = true;
          pp.headers = headers;
        },

        _restoreProvider: function() {
          const pp = this.nxProvider;
          if (!pp) {
            return;
          }

          pp.enrichers = this._pageProviderInfo.enrichers;
          pp.schemas = this._pageProviderInfo.schemas;
          pp.headers = this._pageProviderInfo.headers;
        },

        // ==================================================
        // Fetch new page
        // ==================================================
        // Centralize fetching a new page. The callback pickIndexCallback(len) is used to
        // pick the new index within the new page (len is the number of entries in the new page)
        // These are *not* called in the context of a nuxeo-results.
        _fetchPage(page, pickIndexCallback) {
          const pp = this.nxProvider;
          if (!pp) {
            return;
          }

          this._prepareProvider();

          this._loading = true;
          pp.page = page;
          pp.fetch()
            .then((result) => {
              const len = (result && result.entries) ? result.entries.length : 0;
              const targetIndex = Math.max(0, Math.min(pickIndexCallback(len), Math.max(0, len - 1)));
              this._documents = result;
              this._entrieslength = len;
              this._index = (len ? targetIndex : 0);

              this._hasLoadedOnce = true;
            })
            .catch((err) => {
              console.error("Error while fetching page #: " + page + ": ", err);
            })
            .finally(() => {
              this._loading = false;
              this._restoreProvider();
            });
        },

        _firstFetch: function() {
          if (this._visible && !this._hasLoadedOnce) {
            this._fetchPage(1, () => 0);
          }
        },

        _fetchNextPage: function () {
          this._fetchPage(this.nxProvider.page + 1, () => 0);
        },

        _fetchPreviousPage: function () {
          this._fetchPage(this.nxProvider.page - 1, (len) => len - 1);
        },
        
        _gotoNth: function(n) {
          // If provider not ready, do nothing.
          var pp = this.nxProvider;
          if(!pp) {
            return;
          }

          var targetPage = Math.floor((n - 1) / pp.pageSize) + 1;   // 1-based page
          var targetIndex = (n - 1) % pp.pageSize;                  // 0-based index within page

          // If already on the desired page, just switch index.
          if (pp.page === targetPage && this._documents && this._documents.entries) {
            var len = this._documents.entries.length;
            this._index = Math.min(targetIndex, Math.max(0, len - 1));
            return;
          }

          this._fetchPage(targetPage, () => targetIndex);
        },

        // ==================================================
        // Current document
        // ==================================================
        _loadDocFromIndex(idx) {
          let len = this._entrieslength;
          if(len < 1) {
            return null;
          }

          if (typeof idx !== "number") {
            idx = this._index;
          }

          if (idx < 0) {
            idx = 0;
          } else if (idx >= len) {
            idx = len - 1;
          }

          if (this._documents && this._documents.entries) {
            let docId = this._documents.entries[idx].uid;
            let docObj = this.$.currentDocument;
            docObj.docId = docId;
            docObj.get()
                  .then((result) => {
                    this._currentdocument = result;// => triggers changes in nuxeo-se-document-viewer
                  })
                  .catch((err) => {
                    console.error("Error fetching doc ID " + docId + ": ", err);
                  });
          }

          return null;
        },

        _refreshCurrent: function () {
          let len = this._entrieslength;

          if (!len) {
            this._currentdocument = null;
            return;
          }
          this._loadDocFromIndex();
          
        },

        _url: function(uuid) {
          if(!uuid) {
            return '';
          }

          return `${this.$.nxcon.url}/ui/#!/doc/${uuid}`;
        },

        // ==================================================
        // Navigation
        // ==================================================
        _hasNextPage: function () {
          if (this.nxProvider) {
            let pp = this.nxProvider;
            if( pp.numberOfPages) {
              return pp.page < pp.numberOfPages;  
            }
            return pp.isNextPageAvailable;
          }
          return false;
        },

        _hasPreviousPage: function () {
          if (this.nxProvider) {
            let pp = this.nxProvider;
            return pp.isPreviousPageAvailable || pp.page > 1;
          }
          return false;
        },

        _isPrevDisabled: function (length, index, loading) {
          if (!length || loading) {
            return true;
          }

          if (index > 0) {
            return false;
          }

          // First element of current page => do we have previous page(s)?
          return !this._hasPreviousPage();
        },

        _isNextDisabled: function (length, index, loading) {
          if (!length || loading) {
            return true;
          }

          if (index < length - 1) {
            return false;
          }

          // Last element of current page => do we have more page(s)?
          return !this._hasNextPage()
        },

        // Either we navigate in current entries, or we ask for a new page
        // We change this._index, wich triggers the loading of current doc from the entries.
        _next: function () {
          var len = this._entrieslength;
          if (!len) {
            return;
          }

          if (this._index < len - 1) {
            this._index += 1;
            this._ensureContainerFocus();
            return;
          }

          // At end of page: try to fetch next page
          if (this._hasNextPage()) {
            this._fetchNextPage();
          } else {
            // Reached absolute end, ensure container keeps focus
            this._ensureContainerFocus();
          }
        },

        _prev: function () {
          var len = this._entrieslength;
          if (!len) {
            return;
          }

          if (this._index > 0) {
            this._index = this._index - 1;
            this._ensureContainerFocus();
            return;
          }

          // At start of page: try to fetch previous page
          if (this._hasPreviousPage()) {
            // After previous page fetch, jump to last item
            this._fetchPreviousPage();
          } else {
            // Reached absolute beginning, ensure container keeps focus
            this._ensureContainerFocus();
          }
        },

        // ==================================================
        // Focus and Keyboard
        // ==================================================
        // Ensure the carousel container maintains focus after navigation
        // This prevents focus loss when buttons become disabled
        _ensureContainerFocus: function() {
          Polymer.RenderStatus.afterNextRender(this, () => {
            if (document.activeElement !== this) {
              this.focus();
            }
          });
        },

        _onKeyDown: function (e) {
          // Handle arrow keys when carousel container is focused
          if (e.key === 'ArrowLeft') {
            e.preventDefault();
            this._prev();
          } else if (e.key === 'ArrowRight') {
            e.preventDefault();
            this._next();
          }
        },

        // ==================================================
        // Position and GoToNth
        // ==================================================
        _positionLabel: function(pp, index, pageLen) {
          // If provider not ready, display nothing.
          if(!pp) {
            return "";
          }

          if(!this._entrieslength) {
            return "";
          }
          
          let total = pp.resultsCount;
          let cur = ((pp.page - 1) * pp.pageSize) + (index + 1);
          return cur + ' / ' + total;
        },

        _promptJump: function() {
          // If provider not ready, do nothing.
          var pp = this.nxProvider;
          if(!pp) {
            return;
          }

          var total = pp.resultsCount;
          var def = ((pp.page - 1) * pp.pageSize) + (this._index + 1);

          let label = this._my_i18n("carousel.prompt.goTo", "Go to position (1..<VALUE>):");
          label = label.indexOf("<VALUE>") > -1 ? label.replace("<VALUE>", total) : label;
          var input = window.prompt(label, def);
          if (input == null) { // user cancelled
            return;
          }
          var n = parseInt(input, 10);
          if (!Number.isFinite(n) || n < 1) {
            return;
          }

          if(n > total) {
            n = total;
          } else if(n < 1) {
            n = 1;
          }

          this._gotoNth(n);
        },

        // ==================================================
        // The usual "Misc."
        // ==================================================
        _my_i18n: function(key, def) {
          let label = this.i18n(key);
          if(label === key) {
            return def;
          }
          return label;
        }
      });
    })();
  </script>
</dom-module>