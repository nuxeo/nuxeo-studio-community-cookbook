<dom-module id="virtual-tree">
  <template>
    <style>
      :host {
        display: flex;
        height: 100%;
        font-family: Arial, sans-serif;
      }

      .container {
        display: flex;
        width: 100%;
        height: 100%;
        gap: 16px;
      }

      .tree-view {
        flex: 0 0 300px;
        border-right: 1px solid #e0e0e0;
        overflow-y: auto;
        padding: 16px;
      }

      .tree-header {
        font-weight: 600;
        margin-bottom: 8px;
        color: #616161;
      }

      .tree-item {
        display: flex;
        align-items: center;
        padding: 8px 4px;
        cursor: pointer;
        user-select: none;
        transition: background-color 0.2s;
        border-radius: 6px;
      }

      .tree-item:hover {
        background-color: #f5f5f5;
      }

      .tree-item.selected {
        background-color: #e3f2fd;
      }

      .tree-item.level-0 { padding-left: 8px; }
      .tree-item.level-1 { padding-left: 24px; }
      .tree-item.level-2 { padding-left: 40px; }
      .tree-item.level-3 { padding-left: 56px; }
      .tree-item.level-4 { padding-left: 72px; }

      .chevron {
        width: 24px;
        height: 24px;
        margin-right: 8px;
        color: #757575;
        flex-shrink: 0;
      }

      .chevron.hidden {
        visibility: hidden;
      }

      .tree-label {
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .results-view {
        flex: 1;
        overflow: auto;
        padding: 16px;
        height: 75vh;
        width: 70vw;
      }

      .loading,
      .no-config {
        text-align: center;
        padding: 20px;
        color: #757575;
      }

      .params-chipbar {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin: 6px 0 16px 0;
      }

      .chip {
        font-size: 12px;
        padding: 4px 8px;
        border: 1px solid #e0e0e0;
        border-radius: 999px;
        background: #fafafa;
      }
    </style>

    <!-- Fetch config (you can swap this to your own provider if needed) -->
    <nuxeo-operation
      id="getTreeConfigOp"
      op="javascript.getTreeConfig_ProductsCountriesCities"
      response="{{treeConfig}}">
    </nuxeo-operation>

    <nuxeo-card>
      <div class="container">
        <!-- Left: Virtual Tree -->
        <div class="tree-view">
          <template is="dom-if" if="[[!treeConfig]]" restamp>
            <div class="loading">Loading configuration…</div>
          </template>

          <template is="dom-if" if="[[treeConfig]]" restamp>
            <div class="tree-header">[[_treeTitle(treeConfig.levels)]]</div>

            <template is="dom-repeat" items="[[treeNodes]]" as="node">
              <div
                class$="tree-item level-[[node.level]] [[_selectedClass(node, selectedIndex)]]"
                on-click="_handleNodeClick"
                data-index$="[[node.index]]"
                role="treeitem"
                aria-level$="[[node.level]]"
                aria-expanded$="[[node.ariaExpanded]]">
                <iron-icon
                  class$="chevron [[_getChevronClass(node, treeConfig.levels.length)]]"
                  icon="[[_getChevronIcon(node.expanded)]]">
                </iron-icon>
                <span class="tree-label">[[node.name]]</span>
              </div>
            </template>
          </template>
        </div>

        <!-- Right: Dynamic resultLayout host -->
        <div class="results-view">
          <template is="dom-if" if="[[!treeConfig]]" restamp>
            <div class="no-config">Results will appear here.</div>
          </template>

          <template is="dom-if" if="[[treeConfig]]" restamp>
            <!-- Small params debug/visibility bar (optional; keep if useful) -->
             <!--
            <div class="params-chipbar">
              <template is="dom-repeat" items="[[treeConfig.levels]]" as="lvl" index-as="i">
                <span class="chip">
                  [[lvl.ppParameter]]:
                  [[_displayParam(params, lvl.ppParameter)]]
                </span>
              </template>
            </div>
            -->

            <!-- Host where we stamp the dynamic layout element -->
            <div id="resultsHost"></div>
          </template>
        </div>
      </div>
    </nuxeo-card>
  </template>

  <script>
    (function() {
      'use strict';

      Polymer({
        is: 'virtual-tree',

        properties: {
          treeConfig: {
            type: Object,
            observer: '_onConfigLoaded'
          },

          treeNodes: {
            type: Array,
            value: function () { return []; }
          },

          /** Currently selected node index (string path like "0-3-1") */
          selectedIndex: {
            type: String,
            value: null
          },

          /** Param bag passed to the result layout (ppParameter → value|null) */
          params: {
            type: Object,
            value: function () { return {}; },
            observer: '_onParamsChanged'
          },

          /** Reference to the stamped result layout element */
          _resultEl: {
            type: Object,
            value: null
          },

          loading: {
            type: Boolean,
            value: false
          },

          NXQL_SUFFIX: {
            type: String,
            value: " AND ecm:isVersion = 0 AND ecm:isProxy = 0 AND ecm:isTrashed = 0 "
          }
        },

        ready: function () {
          // Load configuration (or set from outside by binding `tree-config`)
          this.$.getTreeConfigOp.execute();
        },

        // ==================================================
        // Config + Layout
        // ==================================================
        _onConfigLoaded: function (config) {
          if (!config || !config.levels || !config.levels.length) {
            return;
          }

          // Initialize params with all ppParameters = null
          this.params = this._buildEmptyParams(config.levels);

          // Ensure the dynamic result layout is present and receives initial data
          this._ensureResultLayout();

          // Build root of the virtual tree
          this._loadRootLevel();
        },

        _ensureResultLayout: function () {

          // Use async to ensure the DOM elements exist after the conditional template renders
          this.async(() => {

            // Also, can't access this.$.{someId} in the context of a conditional template,
            // need to use this.$$('#{someId}')
            const resultsHost = this.$$('#resultsHost');
            
            if (!resultsHost) {
              // That is very unfortunate.
              console.error("unable to get #resultsHost...");
              return;
            }

            var tag = this.treeConfig && this.treeConfig.resultLayout;
            if (!tag) {
              console.error("No result layout provided.");
              return;
            }

            // If a previous layout exists and tag changed, remove it
            if (this._resultEl && this._resultEl.tagName.toLowerCase() !== tag) {
              this._resultEl.remove();
              this._resultEl = null;
            }

            // Create the element if not yet created
            if (!this._resultEl) {
              var el = document.createElement(tag);
              // Set once; from now on, we update properties directly
              this._resultEl = el;
              resultsHost.appendChild(el);//this.$.resultsHost.appendChild(el);
            }

            // Feed it the latest config and params
            this._resultEl.params = this.params;

            }, 1);
        },

        _onParamsChanged: function (newParams) {
          if (this._resultEl) {
            this._resultEl.params = newParams;
          }
        },

        // ==================================================
        // Tree building & interaction
        // ==================================================
        _loadRootLevel: function () {
          this.loading = true;
          var firstLevel = this.treeConfig.levels[0];
          var nxql = "SELECT * FROM Document WHERE " + firstLevel.field + " IS NOT NULL " + this.NXQL_SUFFIX;

          this._nxqlQuery(nxql)
            .then(function (res) {
              var entries = res.entries || [];

              var valueMap = {};
              entries.forEach(function (doc) {
                var value = _readProp(doc.properties, firstLevel.field);
                if (value && !valueMap[value]) {
                  valueMap[value] = true;
                }
              });

              var nodes = Object.keys(valueMap).sort().map(function (name, idx) {
                return {
                  name: name,
                  level: 0,
                  index: '0-' + idx,
                  expanded: false,
                  ariaExpanded: 'false',
                  path: [{ field: firstLevel.field, value: name }],
                  children: []
                };
              });

              this.treeNodes = this._flattenNodes(nodes);
              this.loading = false;
            }.bind(this))
            .catch(function (error) {
              console.error('Error loading root level:', error);
              this.loading = false;
            }.bind(this));
        },

        _handleNodeClick: function (e) {
          e.stopPropagation();
          var nodeIndex = e.currentTarget.dataset.index;
          var node = this._findNodeByIndex(nodeIndex);
          if (!node) return;

          this.selectedIndex = nodeIndex;

          var depth = node.path.length; // 1..N
          var isLast = depth >= this.treeConfig.levels.length;

          // Update params from the path (fills selected levels, nulls the rest)
          this._applyParamsFromPath(node.path);

          if (isLast) {
            // Last level: nothing more to expand, right panel will react to params
            return;
          }

          // Toggle & load children for next level
          var expanded = node.expanded;
          node.expanded = !expanded;
          node.ariaExpanded = node.expanded ? 'true' : 'false';

          if (!expanded && node.children.length === 0) {
            this._loadChildren(node, depth);
          } else {
            // Just re-render
            this._refreshTreeView();
          }
        },

        _loadChildren: function (parentNode, levelDepth) {
          // levelDepth is current depth; next level is levels[levelDepth]
          var nextLevel = this.treeConfig.levels[levelDepth];

          var whereClauses = parentNode.path.map(function (p) {
            return p.field + " = '" + this._escapeNxql(p.value) + "'";
          }.bind(this));
          whereClauses.push(nextLevel.field + " IS NOT NULL");

          var nxql = "SELECT * FROM Document WHERE " + whereClauses.join(" AND ") + this.NXQL_SUFFIX;

          this._nxqlQuery(nxql)
            .then(function (res) {
              var entries = res.entries || [];

              var valueMap = {};
              entries.forEach(function (doc) {
                var value = _readProp(doc.properties, nextLevel.field);
                if (value && !valueMap[value]) {
                  valueMap[value] = true;
                }
              });

              var children = Object.keys(valueMap).sort().map(function (name, idx) {
                var childPath = parentNode.path.slice();
                childPath.push({ field: nextLevel.field, value: name });

                return {
                  name: name,
                  level: levelDepth,
                  index: parentNode.index + '-' + idx,
                  expanded: false,
                  ariaExpanded: 'false',
                  path: childPath,
                  children: []
                };
              });

              parentNode.children = children;
              this._refreshTreeView();
            }.bind(this))
            .catch(function (error) {
              console.error('Error loading children:', error);
            }.bind(this));
        },

        _flattenNodes: function (nodes, result) {
          result = result || [];
          nodes.forEach(function (node) {
            result.push(node);
            if (node.expanded && node.children.length > 0) {
              this._flattenNodes(node.children, result);
            }
          }.bind(this));
          return result;
        },

        _refreshTreeView: function () {
          // Re-flatten from the first-level nodes present in current flattened list
          var roots = this.treeNodes.filter(function (n) { return n.level === 0; });
          this.treeNodes = this._flattenNodes(roots);
        },

        _findNodeByIndex: function (index) {
          for (var i = 0; i < this.treeNodes.length; i++) {
            if (this.treeNodes[i].index === index) {
              return this.treeNodes[i];
            }
          }
          return null;
        },

        _applyParamsFromPath: function (path) {
          var levels = this.treeConfig.levels;
          var nextParams = this._buildEmptyParams(levels);
          for (var i = 0; i < path.length && i < levels.length; i++) {
            var pp = levels[i].ppParameter;
            nextParams[pp] = path[i].value;
          }
          this.params = nextParams;
        },

        _buildEmptyParams: function (levels) {
          var params = {};
          levels.forEach(function (levek) {
            params[levek.ppParameter] = null;
          });
          return params;
        },

        // ==================================================
        // Helpers & UI
        // ==================================================
        _treeTitle: function (levels) {
          if (!levels || !levels.length) return 'Virtual tree';
          // Show first label as the root title (e.g., "Product")
          return (levels[0].label || 'Items') + ' (virtual tree)';
        },

        _selectedClass: function (node, selectedIndex) {
          return node && selectedIndex === node.index ? 'selected' : '';
        },

        _getChevronIcon: function (expanded) {
          return expanded ? 'hardware:keyboard-arrow-down' : 'hardware:keyboard-arrow-right';
        },

        _getChevronClass: function (node, totalLevels) {
          var depth = node.path.length;
          var isLast = depth >= totalLevels;
          return isLast ? 'hidden' : '';
        },

        _displayParam: function (params, key) {
          if (!params) return '—';
          var v = params[key];
          return (v === null || v === undefined || v === '') ? '—' : v;
        },

        _escapeNxql: function (str) {
          return String(str).replace(/'/g, "''");
        },

        // ==================================================
        // NXQL fetch (simple GET to page provider endpoint)
        // ==================================================
        _nxqlQuery: function (nxql) {
          var url = '/nuxeo/api/v1/search/execute?query=' + nxql + "&pageSize=100";
          return fetch(url, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json',
              'properties': '*'
            }
          }).then(function (r) { return r.json(); });
        }
      });

      // Safe nested property read: supports 'foo:bar' or 'dc:title'
      function _readProp(obj, dotted) {
        if (!obj || !dotted) return null;
        // Nuxeo props use 'schema:field' form; keep as a single key on the map
        return obj[dotted];
      }
    })();
  </script>
</dom-module>