<!-- virtual-tree

The `virtual-tree` element allows for building a virtual navigation with a tree view on the left and
the list of corresponding documents on the right.

Replace the op attribute of the nuxeo-operation for fetching the configuration. It can even be a
hard-coded JSON if you wish, just respect the expected format and attributes. For example:

{
  "resultLayout": "products-virtual-tree-results",
  "levels": [
    {
      "field": "product:type",
      "label": "Product",
      "ppParameter": "product_type"
    }, {
      "field": "company:country",
      "label": "Country",
      "ppParameter": "company_country"
    }, {
      "field": "company:city",
      "label": "City",
      "ppParameter":
      "company_city"
    }
  ]
}

Contributors:
 * Thibaud Arguillere <https://github.com/ThibArg>
-->
<dom-module id="virtual-tree">
  <template>
    <style>
      :host {
        display: flex;
        height: 100%;
        font-family: Arial, sans-serif;
      }

      .container {
        display: flex;
        width: 100%;
        height: 100%;
        gap: 16px;
      }

      .tree-view {
        flex: 0 0 300px;
        border-right: 1px solid #e0e0e0;
        overflow-y: auto;
        padding: 16px;
      }

      .tree-header {
        font-weight: 600;
        margin-bottom: 8px;
        color: #616161;
      }

      .tree-item {
        display: flex;
        align-items: center;
        padding: 8px 4px;
        cursor: pointer;
        user-select: none;
        transition: background-color 0.2s;
        border-radius: 6px;
      }

      .tree-item:hover {
        background-color: #f5f5f5;
      }

      .tree-item.selected {
        background-color: #e3f2fd;
      }

      .tree-item.level-0 { padding-left: 8px; }
      .tree-item.level-1 { padding-left: 24px; }
      .tree-item.level-2 { padding-left: 40px; }
      .tree-item.level-3 { padding-left: 56px; }
      .tree-item.level-4 { padding-left: 72px; }

      .chevron {
        width: 24px;
        height: 24px;
        margin-right: 8px;
        color: #757575;
        flex-shrink: 0;
      }

      .chevron.hidden {
        visibility: hidden;
      }

      .tree-label {
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .results-view {
        flex: 1;
        overflow: auto;
        padding: 16px;
        height: 75vh;
        width: 70vw;
      }

      .loading,
      .no-config {
        text-align: center;
        padding: 20px;
        color: #757575;
      }

      .params-chipbar {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin: 6px 0 16px 0;
      }

      .chip {
        font-size: 12px;
        padding: 4px 8px;
        border: 1px solid #e0e0e0;
        border-radius: 999px;
        background: #fafafa;
      }
    </style>

    <!-- Fetch config (you can swap this to your own provider if needed) -->
    <nuxeo-operation
      id="getTreeConfigOp"
      op="javascript.ProductCountriesCitiesConfig"
      response="{{treeConfig}}">
    </nuxeo-operation>
    
    <nuxeo-operation
      id="getUniqueValuesOp"
      op="javascript.getUniqueValues">
    </nuxeo-operation>

    <nuxeo-card>
      <div class="container">
        <!-- Left: Virtual Tree -->
        <div class="tree-view">
          <template is="dom-if" if="[[!treeConfig]]" restamp>
            <div class="loading">Loading configuration…</div>
          </template>

          <template is="dom-if" if="[[treeConfig]]" restamp>
            <div class="tree-header">[[_treeTitle(treeConfig.levels)]]</div>

            <template is="dom-repeat" items="[[treeNodes]]" as="node">
              <div
                class$="tree-item level-[[node.level]] [[_selectedClass(node, selectedIndex)]]"
                on-click="_handleNodeClick"
                data-index$="[[node.index]]"
                role="treeitem"
                aria-level$="[[node.level]]"
                aria-expanded$="[[node.ariaExpanded]]">
                <iron-icon
                  class$="chevron [[_getChevronClass(node, treeConfig.levels.length)]]"
                  icon="[[_getChevronIcon(node.expanded)]]">
                </iron-icon>
                <span class="tree-label">[[node.name]]</span>
              </div>
            </template>
          </template>
        </div>

        <!-- Right: Dynamic resultLayout host -->
        <div class="results-view">
          <template is="dom-if" if="[[!treeConfig]]" restamp>
            <div class="no-config">Results will appear here.</div>
          </template>

          <template is="dom-if" if="[[treeConfig]]" restamp>
            <!-- Small params debug/visibility bar. Set _debug to true and reload -->
            <template is="dom-if" if="[[_debug]]" restamp>
              <div class="params-chipbar">
                <template is="dom-repeat" items="[[treeConfig.levels]]" as="lvl" index-as="i">
                  <span class="chip">
                    [[lvl.ppParameter]]:
                    [[_displayParam(params, lvl.ppParameter)]]
                  </span>
                </template>
              </div>
            </template>
            
            <!-- Host where we stamp the dynamic layout element -->
            <div id="resultsHost"></div>
          </template>
        </div>
      </div>
    </nuxeo-card>
  </template>

  <script>
    (function() {
      'use strict';

      Polymer({
        is: 'virtual-tree',
        behaviors: [Polymer.IronResizableBehavior], // required to compyute visibility and avoid fetching values every time the user refreshes a page

        properties: {
          _debug: {
            type: Boolean,
            value: false
          },

          treeConfig: {
            type: Object,
            observer: '_onConfigLoaded'
          },

          treeNodes: {
            type: Array,
            value: function () { return []; }
          },

          // Currently selected node index (string path like "0-3-1")
          selectedIndex: {
            type: String,
            value: null
          },

          // Parameter bag passed to the result layout (ppParameter → value|null)
          params: {
            type: Object,
            value: function () { return {}; },
            observer: '_onParamsChanged'
          },

          // Reference to the stamped result layout element
          _resultEl: {
            type: Object,
            value: null
          },

          loading: {
            type: Boolean,
            value: false
          },

          NXQL_SUFFIX: {
            type: String,
            value: " AND ecm:isVersion = 0 AND ecm:isProxy = 0 AND ecm:isTrashed = 0 "
          },

          _visible: {
            type: Boolean,
            value: false,
            observer: "_visibleChanged"
          }
        },

        listeners: {
          'iron-resize': '_computeVisible'
        },

        _computeVisible() {
          this._visible = Boolean(this.offsetWidth || this.offsetHeight);
        },

        _visibleChanged: function(newValue, prevValue) {
          if(newValue) {
            this.$.getTreeConfigOp.execute();
          }
        },

        ready: function () {
          // Don't put it here, or it is calculated everytime the user refreshes or force refresh
          // Load configuration (or set from outside by binding `tree-config`)
          //this.$.getTreeConfigOp.execute();
        },

        // ==================================================
        // Config + Layout
        // ==================================================
        _onConfigLoaded: function (config) {
          if (!config || !config.levels || !config.levels.length) {
            return;
          }

          // Initialize params with all ppParameters = null
          this.params = this._buildEmptyParams(config.levels);

          // Ensure the dynamic result layout is present and receives initial data
          this._addResultLayout();

          // Build root of the virtual tree
          this._loadRootLevel();
        },

        _addResultLayout: function () {

          // Use async to ensure the DOM elements exist after the conditional template renders
          this.async(() => {

            // Also, can't access this.$.{someId} in the context of a conditional template,
            // need to use this.$$('#{someId}')
            const resultsHost = this.$$('#resultsHost');
            
            if (!resultsHost) {
              // That is very unfortunate.
              console.error("unable to get #resultsHost...");
              return;
            }

            var tag = this.treeConfig && this.treeConfig.resultLayout;
            if (!tag) {
              console.error("No result layout provided.");
              return;
            }

            // If a previous layout exists and tag changed, remove it
            if (this._resultEl && this._resultEl.tagName.toLowerCase() !== tag) {
              this._resultEl.remove();
              this._resultEl = null;
            }

            // Create the element if not yet created
            if (!this._resultEl) {
              var el = document.createElement(tag);
              // Set once; from now on, we update properties directly
              this._resultEl = el;
              resultsHost.appendChild(el);//this.$.resultsHost.appendChild(el);
            }

            // Feed it the latest config and params
            this._resultEl.params = this.params;

            }, 1);
        },

        _onParamsChanged: function (newParams) {
          if (this._resultEl) {
            this._resultEl.params = newParams;
          }
        },

        // ==================================================
        // Tree building & interaction
        // ==================================================
        _loadRootLevel: function () {
          let firstLevel = this.treeConfig.levels[0];

          let op = this.$.getUniqueValuesOp;

          // First item is first level
          let xpath = this.treeConfig.levels[0].field;
          let whereClause = xpath + " IS NOT NULL " + this.NXQL_SUFFIX;

          let params = {
            xpath: xpath,
            whereClause: whereClause
          };

          op.params = params;

          this.loading = true;

          op.execute()
            .then(function (res) {
              let nodes = [];
              if(Array.isArray(res) && res.length > 0) {
                nodes = res.sort().map(function (name, idx) {
                  return {
                    name: name,
                    level: 0,
                    index: '0-' + idx,
                    expanded: false,
                    ariaExpanded: 'false',
                    path: [{ field: firstLevel.field, value: name }],
                    children: []
                  };
                }.bind(this));
              }
              this.treeNodes = this._flattenNodes(nodes);
              
            }.bind(this))
            .catch(function(error) {
              console.error('Error loading root level (op):', error);
            }.bind(this))
            .finally(function() {
              this.loading = false;
            }.bind(this));

        },

        _handleNodeClick: function (e) {
          e.stopPropagation();
          var nodeIndex = e.currentTarget.dataset.index;
          var node = this._findNodeByIndex(nodeIndex);
          if (!node) return;

          this.selectedIndex = nodeIndex;

          var depth = node.path.length; // 1..N
          var isLast = depth >= this.treeConfig.levels.length;

          // Update params from the path (fills selected levels, nulls the rest)
          this._applyParamsFromPath(node.path);

          if (isLast) {
            // Last level: nothing more to expand, right panel will react to params
            return;
          }

          // Toggle & load children for next level
          var expanded = node.expanded;
          node.expanded = !expanded;
          node.ariaExpanded = node.expanded ? 'true' : 'false';

          if (!expanded && node.children.length === 0) {
            this._loadChildren(node, depth);
          } else {
            // Just re-render
            this._refreshTreeView();
          }
        },

        _loadChildren: function (parentNode, levelDepth) {
          // levelDepth is current depth; next level is levels[levelDepth]
          let nextLevel = this.treeConfig.levels[levelDepth];

          let op = this.$.getUniqueValuesOp;

          let whereClauses = parentNode.path.map(function (p) {
            return p.field + " = '" + this._escapeNxql(p.value) + "'";
          }.bind(this));
          whereClauses.push(nextLevel.field + " IS NOT NULL");

          op.params = {
            xpath: nextLevel.field,
            whereClause: whereClauses.join(" AND ") + this.NXQL_SUFFIX
          };

          this.loading = true;
          op.execute()
            .then(function (res) {
              let children = [];
              if(Array.isArray(res) && res.length > 0) {
                children = res.sort().map(function (name, idx) {
                  let childPath = parentNode.path.slice();
                  childPath.push({ field: nextLevel.field, value: name });

                  return {
                    name: name,
                    level: levelDepth,
                    index: parentNode.index + '-' + idx,
                    expanded: false,
                    ariaExpanded: 'false',
                    path: childPath,
                    children: []
                  };
                }.bind(this));
              }

              parentNode.children = children;
              this._refreshTreeView();
              
            }.bind(this))
            .catch(function(error) {
              console.error('Error loading children:', error);
            }.bind(this))
            .finally(function() {
              this.loading = false;
            }.bind(this));

        },

        _flattenNodes: function (nodes, result) {
          result = result || [];
          nodes.forEach(function (node) {
            result.push(node);
            if (node.expanded && node.children.length > 0) {
              this._flattenNodes(node.children, result);
            }
          }.bind(this));
          return result;
        },

        _refreshTreeView: function () {
          // Re-flatten from the first-level nodes present in current flattened list
          var roots = this.treeNodes.filter(function (n) { return n.level === 0; });
          this.treeNodes = this._flattenNodes(roots);
        },

        _findNodeByIndex: function (index) {
          for (var i = 0; i < this.treeNodes.length; i++) {
            if (this.treeNodes[i].index === index) {
              return this.treeNodes[i];
            }
          }
          return null;
        },

        _applyParamsFromPath: function (path) {
          var levels = this.treeConfig.levels;
          var nextParams = this._buildEmptyParams(levels);
          for (var i = 0; i < path.length && i < levels.length; i++) {
            var pp = levels[i].ppParameter;
            nextParams[pp] = path[i].value;
          }
          this.params = nextParams;
        },

        _buildEmptyParams: function (levels) {
          var params = {};
          levels.forEach(function (levek) {
            params[levek.ppParameter] = null;
          });
          return params;
        },

        // ==================================================
        // Helpers & UI
        // ==================================================
        _treeTitle: function (levels) {
          if (!levels || !levels.length) return 'Virtual tree';
          // Show first label as the root title (e.g., "Product")
          return (levels[0].label || 'Items') + ' (virtual tree)';
        },

        _selectedClass: function (node, selectedIndex) {
          return node && selectedIndex === node.index ? 'selected' : '';
        },

        _getChevronIcon: function (expanded) {
          return expanded ? 'hardware:keyboard-arrow-down' : 'hardware:keyboard-arrow-right';
        },

        _getChevronClass: function (node, totalLevels) {
          var depth = node.path.length;
          var isLast = depth >= totalLevels;
          return isLast ? 'hidden' : '';
        },

        _displayParam: function (params, key) {
          if (!params) return '—';
          var v = params[key];
          return (v === null || v === undefined || v === '') ? '—' : v;
        },

        _escapeNxql: function (str) {
          return String(str).replace(/'/g, "''");
        }
        
      });
    })();
  </script>
</dom-module>